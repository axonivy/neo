/**
 * Generated by orval v7.14.0 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import { customFetch } from '../custom-fetch';
export interface FeedbackModelRequest {
  /** Product id (from meta.json) */
  productId: string;
  /**
   * User's feedback content
   * @minLength 0
   * @maxLength 250
   */
  content: string;
  /**
   * User's rating point of target product
   * @minimum 1
   * @maximum 5
   */
  rating?: number;
}

export interface Links {
  [key: string]: Link;
}

export interface PageMetadata {
  size?: number;
  totalElements?: number;
  totalPages?: number;
  number?: number;
}

export type _PagedModelProductModelEmbedded = {
  products?: ProductModel[];
};

export interface PagedModelProductModel {
  _embedded?: _PagedModelProductModelEmbedded;
  _links?: Links;
  page?: PageMetadata;
}

/**
 * Product name by locale
 */
export type ProductModelNames = { [key: string]: string };

/**
 * Product's short descriptions by locale
 */
export type ProductModelShortDescriptions = { [key: string]: string };

export interface ProductModel {
  /** Product id */
  id?: string;
  /** Product name by locale */
  names?: ProductModelNames;
  /** Product's short descriptions by locale */
  shortDescriptions?: ProductModelShortDescriptions;
  /** Product's logo url */
  logoUrl?: string;
  /** Type of product */
  type?: string;
  /** Tags of product */
  tags?: string[];
  _links?: Links;
}

export interface GitHubReleaseModel {
  /** Version of release */
  name?: string;
  /** Body of release */
  body?: string;
  /** Published date of release */
  publishedAt?: string;
  /** Link of release */
  htmlUrl?: string;
  latestRelease?: boolean;
  _links?: Links;
}

/**
 * Product name by locale
 */
export type ProductDetailModelNames = { [key: string]: string };

/**
 * Product's short descriptions by locale
 */
export type ProductDetailModelShortDescriptions = { [key: string]: string };

export interface ProductDetailModel {
  /** Product id */
  id?: string;
  /** Product name by locale */
  names?: ProductDetailModelNames;
  /** Product's short descriptions by locale */
  shortDescriptions?: ProductDetailModelShortDescriptions;
  /** Product's logo url */
  logoUrl?: string;
  /** Type of product */
  type?: string;
  /** Tags of product */
  tags?: string[];
  /** Product vendor */
  vendor?: string;
  /** Product vendor url */
  vendorUrl?: string;
  /** Product vendor image */
  vendorImage?: string;
  /** Product vendor image dark mode */
  vendorImageDarkMode?: string;
  /** Platform review */
  platformReview?: string;
  /** Latest release version from maven */
  newestReleaseVersion?: string;
  /** Product cost */
  cost?: string;
  /** Source repository url */
  sourceUrl?: string;
  /** Status badge url */
  statusBadgeUrl?: string;
  /** Default language */
  language?: string;
  /** Product industry */
  industry?: string;
  /** Can contact us */
  contactUs?: boolean;
  /** Is deprecated product */
  deprecated?: boolean;
  productModuleContent?: ProductModuleContent;
  /** Installation/download count */
  installationCount?: number;
  /** The api url to get metadata from product.json */
  metaProductJsonUrl?: string;
  /** Compatibility */
  compatibilityRange?: string;
  mavenDropins?: boolean;
  _links?: Links;
}

/**
 * Product detail description content
 */
export type ProductModuleContentDescription = { [key: string]: string };

/**
 * Setup tab content
 */
export type ProductModuleContentSetup = { [key: string]: string };

/**
 * Demo tab content
 */
export type ProductModuleContentDemo = { [key: string]: string };

export interface ProductModuleContent {
  createdAt?: string;
  updatedAt?: string;
  id?: string;
  /** product Id (from meta.json) */
  productId?: string;
  /** Maven version */
  version?: string;
  /** Product detail description content  */
  description?: ProductModuleContentDescription;
  /** Setup tab content */
  setup?: ProductModuleContentSetup;
  /** Demo tab content */
  demo?: ProductModuleContentDemo;
  /** Is dependency artifact */
  isDependency?: boolean;
  name?: string;
  /** Product artifact's group id */
  groupId?: string;
  /** Product artifact's artifact id */
  artifactId?: string;
  /** Artifact file type */
  type?: string;
}

export interface StreamingResponseBody {
  [key: string]: unknown;
}

export interface MavenArtifactKey {
  artifactId?: string;
  productVersion?: string;
  additionalVersion?: boolean;
}

export interface MavenArtifactVersion {
  createdAt?: string;
  updatedAt?: string;
  id?: MavenArtifactKey;
  /** Display name and type of artifact */
  name?: string;
  /** Artifact download url */
  downloadUrl?: string;
  groupId?: string;
  productId?: string;
}

export interface MavenArtifactVersionModel {
  /** Target version */
  version?: string;
  artifactsByVersion?: MavenArtifactVersion[];
}

export type _PagedModelGitHubReleaseModelEmbedded = {
  gitHubReleaseModelList?: GitHubReleaseModel[];
};

export interface PagedModelGitHubReleaseModel {
  _embedded?: _PagedModelGitHubReleaseModelEmbedded;
  _links?: Links;
  page?: PageMetadata;
}

export interface VersionAndUrlModel {
  version?: string;
  url?: string;
}

export interface DesignerInstallation {
  /** Ivy designer version */
  designerVersion?: string;
  numberOfDownloads?: number;
}

export interface GithubReposModel {
  /** Repository name */
  repoName?: string;
  /** Product id */
  productId?: string;
  /** Repository HTML URL */
  htmlUrl?: string;
  workflowInformation?: WorkflowInformation[];
  /** Indicates if the repository is a focused repository */
  focused?: boolean;
  /** Test results summary by workflow type and test environment */
  testResults?: TestResults[];
}

export type TestResultsWorkflow = (typeof TestResultsWorkflow)[keyof typeof TestResultsWorkflow];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TestResultsWorkflow = {
  CI: 'CI',
  DEV: 'DEV',
  E2E: 'E2E'
} as const;

export type TestResultsResults = { [key: string]: number };

/**
 * Test results summary by workflow type and test environment
 */
export interface TestResults {
  workflow?: TestResultsWorkflow;
  /**
   * CI workflow badge URL
   * @deprecated
   */
  badgeUrl?: string;
  results?: TestResultsResults;
}

export type WorkflowInformationWorkflowType = (typeof WorkflowInformationWorkflowType)[keyof typeof WorkflowInformationWorkflowType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WorkflowInformationWorkflowType = {
  CI: 'CI',
  DEV: 'DEV',
  E2E: 'E2E'
} as const;

export interface WorkflowInformation {
  id?: string;
  workflowType?: WorkflowInformationWorkflowType;
  lastBuilt?: string;
  conclusion?: string;
  lastBuiltRunUrl?: string;
}

export interface Image {
  id?: string;
  /** Product id */
  productId?: string;
  /** The download url from github */
  imageUrl?: string;
  /** The image content as byte array */
  imageData?: string[];
  /** The SHA from github */
  sha?: string;
}

/**
 * Product name (from meta.json)
 */
export type FeedbackModelProductNames = { [key: string]: string };

/**
 * User's feedback status
 */
export type FeedbackModelFeedbackStatus = (typeof FeedbackModelFeedbackStatus)[keyof typeof FeedbackModelFeedbackStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FeedbackModelFeedbackStatus = {
  APPROVED: 'APPROVED',
  PENDING: 'PENDING',
  REJECTED: 'REJECTED'
} as const;

export interface FeedbackModel {
  /** Id of feedback */
  id?: string;
  /** User Id */
  userId?: string;
  /** Github username */
  username?: string;
  /** Url of github avatar */
  userAvatarUrl?: string;
  /** 3rd party login provider */
  userProvider?: string;
  /** Product id (from meta.json) */
  productId?: string;
  /** Product name (from meta.json) */
  productNames?: FeedbackModelProductNames;
  /** User's feedback content */
  content?: string;
  /**
   * User's rating point of target product
   * @minimum 1
   * @maximum 5
   */
  rating?: number;
  /** Feedback/rating creating timestamp */
  createdAt?: string;
  /** Latest feedback/rating updating timestamp */
  updatedAt?: string;
  /** User's feedback status */
  feedbackStatus?: FeedbackModelFeedbackStatus;
  /** Moderator name reviewed feedback */
  moderatorName?: string;
  /** Feedback reviewing timestamp */
  reviewDate?: string;
  /** Feedback modification version */
  version?: number;
  /** Is latest approved or pending feedback */
  isLatest?: boolean;
  _links?: Links;
}

export type _PagedModelFeedbackModelEmbedded = {
  feedbacks?: FeedbackModel[];
};

export interface PagedModelFeedbackModel {
  _embedded?: _PagedModelFeedbackModelEmbedded;
  _links?: Links;
  page?: PageMetadata;
}

export interface ProductRating {
  /** Specific rating point of product */
  starRating?: number;
  /** Count of rating on this specific point */
  commentNumber?: number;
  /** Weight ration of this point/ total point */
  percent?: number;
}

export interface ExternalDocumentModel {
  /** Product id */
  productId?: string;
  /** Name of artifact */
  artifactName?: string;
  /** Version of artifact */
  version?: string;
  /** Relative link of document page */
  relativeLink?: string;
  _links?: Links;
}

export interface DocumentInfoResponse {
  versions?: DocumentVersion[];
  languages?: DocumentLanguage[];
}

export interface DocumentLanguage {
  language?: string;
  url?: string;
}

export interface DocumentVersion {
  version?: string;
  url?: string;
}

export interface Link {
  href?: string;
  hreflang?: string;
  title?: string;
  type?: string;
  deprecation?: string;
  profile?: string;
  name?: string;
  templated?: boolean;
}

export type FindFeedbackByUserIdAndProductIdParams = {
  /**
   * Id of current user from DB
   */
  userId: string;
  /**
   * Product id (from meta.json)
   */
  productId: string;
};

export type FindProductsParams = {
  /**
   * Page number to retrieve
   * @minimum 0
   */
  page: number;
  /**
   * Number of items per page
   * @minimum 1
   */
  size?: number;
  /**
   * Sorting criteria in the format: Sorting criteria(popularity|alphabetically|recent), Sorting order(asc|desc)
   */
  sort: string[];
  /**
   * Type of product.
   */
  type: FindProductsType;
  /**
   * Keyword that exist in product's name or short description
   */
  keyword?: string;
  /**
   * Language of product short description
   */
  language: FindProductsLanguage;
  /**
   * Option to render the website in the REST Client Editor of Designer
   */
  isRESTClient: boolean;
};

export type FindProductsType = (typeof FindProductsType)[keyof typeof FindProductsType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FindProductsType = {
  all: 'all',
  connectors: 'connectors',
  utilities: 'utilities',
  solutions: 'solutions',
  demos: 'demos'
} as const;

export type FindProductsLanguage = (typeof FindProductsLanguage)[keyof typeof FindProductsLanguage];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FindProductsLanguage = {
  en: 'en',
  de: 'de'
} as const;

export type FindProductDetailsParams = {
  /**
   * Option to get Dev Version (Snapshot/ sprint release)
   */
  isShowDevVersion?: boolean;
};

export type FindProductJsonContentParams = {
  designerVersion?: string;
};

export type FindProductJsonContent200 = { [key: string]: { [key: string]: unknown } };

export type FindProductVersionsByIdParams = {
  /**
   * Option to get Dev Version (Snapshot/ sprint release)
   */
  isShowDevVersion: boolean;
  designerVersion?: string;
};

export type FindGithubPublicReleasesParams = {
  /**
   * Page number to retrieve
   * @minimum 0
   */
  page: number;
  /**
   * Number of items per page
   * @minimum 1
   */
  size?: number;
  /**
   * Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   */
  sort?: string[];
};

export type FindVersionsForDesignerParams = {
  designerVersion?: string;
  /**
   * Option to get Dev Version (Snapshot/ sprint release)
   */
  isShowDevVersion: boolean;
};

export type GetLatestArtifactDownloadUrlParams = {
  version: string;
  artifact: string;
};

export type FindFeedbacksParams = {
  /**
   * Page number to retrieve
   * @minimum 0
   */
  page: number;
  /**
   * Number of items per page
   * @minimum 1
   */
  size?: number;
  /**
   * Sorting criteria in the format: Sorting criteria(popularity|alphabetically|recent), Sorting order(asc|desc)
   */
  sort: string[];
};

export type RedirectToBestVersionParams = {
  path?: string;
};

export type findInstallationCountResponse200 = {
  data: number;
  status: 200;
};

export type findInstallationCountResponseSuccess = findInstallationCountResponse200 & {
  headers: Headers;
};
export type findInstallationCountResponse = findInstallationCountResponseSuccess;

export const getFindInstallationCountUrl = (id: string) => {
  return `/api/product-marketplace-data/installation-count/${id}`;
};

export const findInstallationCount = async (id: string, options?: RequestInit): Promise<findInstallationCountResponse> => {
  return customFetch<findInstallationCountResponse>(getFindInstallationCountUrl(id), {
    ...options,
    method: 'PUT'
  });
};

/**
 * Load and store test reports from GitHub repositories
 * @summary Sync GitHub monitor
 */
export type syncGithubMonitorResponse200 = {
  data: string;
  status: 200;
};

export type syncGithubMonitorResponseSuccess = syncGithubMonitorResponse200 & {
  headers: Headers;
};
export type syncGithubMonitorResponse = syncGithubMonitorResponseSuccess;

export const getSyncGithubMonitorUrl = () => {
  return `/api/monitor-dashboard/sync`;
};

export const syncGithubMonitor = async (options?: RequestInit): Promise<syncGithubMonitorResponse> => {
  return customFetch<syncGithubMonitorResponse>(getSyncGithubMonitorUrl(), {
    ...options,
    method: 'PUT'
  });
};

/**
 * Get current user feedback on target product.
 * @summary Find all feedbacks by user id and product id
 */
export type findFeedbackByUserIdAndProductIdResponse200 = {
  data: FeedbackModel[];
  status: 200;
};

export type findFeedbackByUserIdAndProductIdResponseSuccess = findFeedbackByUserIdAndProductIdResponse200 & {
  headers: Headers;
};
export type findFeedbackByUserIdAndProductIdResponse = findFeedbackByUserIdAndProductIdResponseSuccess;

export const getFindFeedbackByUserIdAndProductIdUrl = (params: FindFeedbackByUserIdAndProductIdParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/feedback?${stringifiedParams}` : `/api/feedback`;
};

export const findFeedbackByUserIdAndProductId = async (
  params: FindFeedbackByUserIdAndProductIdParams,
  options?: RequestInit
): Promise<findFeedbackByUserIdAndProductIdResponse> => {
  return customFetch<findFeedbackByUserIdAndProductIdResponse>(getFindFeedbackByUserIdAndProductIdUrl(params), {
    ...options,
    method: 'GET'
  });
};

/**
 * Save user feedback of product with their token from Github account.
 * @summary Create user feedback
 */
export type createFeedbackResponse201 = {
  data: void;
  status: 201;
};

export type createFeedbackResponse401 = {
  data: void;
  status: 401;
};

export type createFeedbackResponseSuccess = createFeedbackResponse201 & {
  headers: Headers;
};
export type createFeedbackResponseError = createFeedbackResponse401 & {
  headers: Headers;
};

export type createFeedbackResponse = createFeedbackResponseSuccess | createFeedbackResponseError;

export const getCreateFeedbackUrl = () => {
  return `/api/feedback`;
};

export const createFeedback = async (
  feedbackModelRequest: FeedbackModelRequest,
  options?: RequestInit
): Promise<createFeedbackResponse> => {
  return customFetch<createFeedbackResponse>(getCreateFeedbackUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(feedbackModelRequest)
  });
};

/**
 * By default, the system finds products with type 'all'
 * @summary Retrieve a paginated list of all products, optionally filtered by type, keyword, and language
 */
export type findProductsResponse200 = {
  data: PagedModelProductModel;
  status: 200;
};

export type findProductsResponseSuccess = findProductsResponse200 & {
  headers: Headers;
};
export type findProductsResponse = findProductsResponseSuccess;

export const getFindProductsUrl = (params: FindProductsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ['sort'];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach(v => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/product?${stringifiedParams}` : `/api/product`;
};

export const findProducts = async (params: FindProductsParams, options?: RequestInit): Promise<findProductsResponse> => {
  return customFetch<findProductsResponse>(getFindProductsUrl(params), {
    ...options,
    method: 'GET'
  });
};

/**
 * Get release by product id and release id
 * @summary Find release by product id and release id
 */
export type findGithubPublicReleaseByProductIdAndReleaseIdResponse200 = {
  data: GitHubReleaseModel;
  status: 200;
};

export type findGithubPublicReleaseByProductIdAndReleaseIdResponseSuccess = findGithubPublicReleaseByProductIdAndReleaseIdResponse200 & {
  headers: Headers;
};
export type findGithubPublicReleaseByProductIdAndReleaseIdResponse = findGithubPublicReleaseByProductIdAndReleaseIdResponseSuccess;

export const getFindGithubPublicReleaseByProductIdAndReleaseIdUrl = (productId: string, releaseId: number) => {
  return `/api/product-details/${productId}/releases/${releaseId}`;
};

export const findGithubPublicReleaseByProductIdAndReleaseId = async (
  productId: string,
  releaseId: number,
  options?: RequestInit
): Promise<findGithubPublicReleaseByProductIdAndReleaseIdResponse> => {
  return customFetch<findGithubPublicReleaseByProductIdAndReleaseIdResponse>(
    getFindGithubPublicReleaseByProductIdAndReleaseIdUrl(productId, releaseId),
    {
      ...options,
      method: 'GET'
    }
  );
};

/**
 * Return product detail by product id (from meta.json)
 * @summary get product detail by ID
 */
export type findProductDetailsResponse200 = {
  data: ProductDetailModel;
  status: 200;
};

export type findProductDetailsResponseSuccess = findProductDetailsResponse200 & {
  headers: Headers;
};
export type findProductDetailsResponse = findProductDetailsResponseSuccess;

export const getFindProductDetailsUrl = (id: string, params?: FindProductDetailsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/product-details/${id}?${stringifiedParams}` : `/api/product-details/${id}`;
};

export const findProductDetails = async (
  id: string,
  params?: FindProductDetailsParams,
  options?: RequestInit
): Promise<findProductDetailsResponse> => {
  return customFetch<findProductDetailsResponse>(getFindProductDetailsUrl(id, params), {
    ...options,
    method: 'GET'
  });
};

/**
 * get product detail by it product id and release version
 * @summary Find product detail by product id and release version.
 */
export type findProductDetailsByVersionResponse200 = {
  data: ProductDetailModel;
  status: 200;
};

export type findProductDetailsByVersionResponseSuccess = findProductDetailsByVersionResponse200 & {
  headers: Headers;
};
export type findProductDetailsByVersionResponse = findProductDetailsByVersionResponseSuccess;

export const getFindProductDetailsByVersionUrl = (id: string, version: string) => {
  return `/api/product-details/${id}/${version}`;
};

export const findProductDetailsByVersion = async (
  id: string,
  version: string,
  options?: RequestInit
): Promise<findProductDetailsByVersionResponse> => {
  return customFetch<findProductDetailsByVersionResponse>(getFindProductDetailsByVersionUrl(id, version), {
    ...options,
    method: 'GET'
  });
};

/**
 * When we click install in designer, this API will send content of product json for installing in Ivy designer
 * @summary Get product json content for designer to install
 */
export type findProductJsonContentResponse200 = {
  data: FindProductJsonContent200;
  status: 200;
};

export type findProductJsonContentResponseSuccess = findProductJsonContentResponse200 & {
  headers: Headers;
};
export type findProductJsonContentResponse = findProductJsonContentResponseSuccess;

export const getFindProductJsonContentUrl = (id: string, version: string, params?: FindProductJsonContentParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/product-details/${id}/${version}/json?${stringifiedParams}`
    : `/api/product-details/${id}/${version}/json`;
};

export const findProductJsonContent = async (
  id: string,
  version: string,
  params?: FindProductJsonContentParams,
  options?: RequestInit
): Promise<findProductJsonContentResponse> => {
  return customFetch<findProductJsonContentResponse>(getFindProductJsonContentUrl(id, version, params), {
    ...options,
    method: 'GET'
  });
};

/**
 * get product detail by it product id and version
 * @summary Find best match product detail by product id and version.
 */
export type findBestMatchProductDetailsByVersionResponse200 = {
  data: ProductDetailModel;
  status: 200;
};

export type findBestMatchProductDetailsByVersionResponseSuccess = findBestMatchProductDetailsByVersionResponse200 & {
  headers: Headers;
};
export type findBestMatchProductDetailsByVersionResponse = findBestMatchProductDetailsByVersionResponseSuccess;

export const getFindBestMatchProductDetailsByVersionUrl = (id: string, version: string) => {
  return `/api/product-details/${id}/${version}/bestmatch`;
};

export const findBestMatchProductDetailsByVersion = async (
  id: string,
  version: string,
  options?: RequestInit
): Promise<findBestMatchProductDetailsByVersionResponse> => {
  return customFetch<findBestMatchProductDetailsByVersionResponse>(getFindBestMatchProductDetailsByVersionUrl(id, version), {
    ...options,
    method: 'GET'
  });
};

/**
 * Return the download url of artifact from version and id
 * @summary Get the download steam of artifact and it's dependencies by it's id and target version
 */
export type downloadZipArtifactResponse200 = {
  data: StreamingResponseBody;
  status: 200;
};

export type downloadZipArtifactResponseSuccess = downloadZipArtifactResponse200 & {
  headers: Headers;
};
export type downloadZipArtifactResponse = downloadZipArtifactResponseSuccess;

export const getDownloadZipArtifactUrl = (id: string, artifactId: string, version: string) => {
  return `/api/product-details/${id}/${artifactId}/${version}/zip-file`;
};

export const downloadZipArtifact = async (
  id: string,
  artifactId: string,
  version: string,
  options?: RequestInit
): Promise<downloadZipArtifactResponse> => {
  return customFetch<downloadZipArtifactResponse>(getDownloadZipArtifactUrl(id, artifactId, version), {
    ...options,
    method: 'GET'
  });
};

export type findProductVersionsByIdResponse200 = {
  data: MavenArtifactVersionModel[];
  status: 200;
};

export type findProductVersionsByIdResponseSuccess = findProductVersionsByIdResponse200 & {
  headers: Headers;
};
export type findProductVersionsByIdResponse = findProductVersionsByIdResponseSuccess;

export const getFindProductVersionsByIdUrl = (id: string, params: FindProductVersionsByIdParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/product-details/${id}/versions?${stringifiedParams}` : `/api/product-details/${id}/versions`;
};

export const findProductVersionsById = async (
  id: string,
  params: FindProductVersionsByIdParams,
  options?: RequestInit
): Promise<findProductVersionsByIdResponse> => {
  return customFetch<findProductVersionsByIdResponse>(getFindProductVersionsByIdUrl(id, params), {
    ...options,
    method: 'GET'
  });
};

/**
 * Get all public releases by product id
 * @summary Find public releases by product id
 */
export type findGithubPublicReleasesResponse200 = {
  data: PagedModelGitHubReleaseModel;
  status: 200;
};

export type findGithubPublicReleasesResponseSuccess = findGithubPublicReleasesResponse200 & {
  headers: Headers;
};
export type findGithubPublicReleasesResponse = findGithubPublicReleasesResponseSuccess;

export const getFindGithubPublicReleasesUrl = (id: string, params: FindGithubPublicReleasesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ['sort'];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach(v => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/product-details/${id}/releases?${stringifiedParams}` : `/api/product-details/${id}/releases`;
};

export const findGithubPublicReleases = async (
  id: string,
  params: FindGithubPublicReleasesParams,
  options?: RequestInit
): Promise<findGithubPublicReleasesResponse> => {
  return customFetch<findGithubPublicReleasesResponse>(getFindGithubPublicReleasesUrl(id, params), {
    ...options,
    method: 'GET'
  });
};

/**
 * Collect the released versions in product for ivy designer
 * @summary Get the list of released version in product
 */
export type findVersionsForDesignerResponse200 = {
  data: VersionAndUrlModel[];
  status: 200;
};

export type findVersionsForDesignerResponseSuccess = findVersionsForDesignerResponse200 & {
  headers: Headers;
};
export type findVersionsForDesignerResponse = findVersionsForDesignerResponseSuccess;

export const getFindVersionsForDesignerUrl = (id: string, params: FindVersionsForDesignerParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/product-details/${id}/designerversions?${stringifiedParams}`
    : `/api/product-details/${id}/designerversions`;
};

export const findVersionsForDesigner = async (
  id: string,
  params: FindVersionsForDesignerParams,
  options?: RequestInit
): Promise<findVersionsForDesignerResponse> => {
  return customFetch<findVersionsForDesignerResponse>(getFindVersionsForDesignerUrl(id, params), {
    ...options,
    method: 'GET'
  });
};

/**
 * Return the download url of artifact from version and id
 * @summary Get the download url of latest version from artifact by its id and target version
 */
export type getLatestArtifactDownloadUrlResponse200 = {
  data: string;
  status: 200;
};

export type getLatestArtifactDownloadUrlResponseSuccess = getLatestArtifactDownloadUrlResponse200 & {
  headers: Headers;
};
export type getLatestArtifactDownloadUrlResponse = getLatestArtifactDownloadUrlResponseSuccess;

export const getGetLatestArtifactDownloadUrlUrl = (id: string, params: GetLatestArtifactDownloadUrlParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/product-details/${id}/artifact?${stringifiedParams}` : `/api/product-details/${id}/artifact`;
};

export const getLatestArtifactDownloadUrl = async (
  id: string,
  params: GetLatestArtifactDownloadUrlParams,
  options?: RequestInit
): Promise<getLatestArtifactDownloadUrlResponse> => {
  return customFetch<getLatestArtifactDownloadUrlResponse>(getGetLatestArtifactDownloadUrlUrl(id, params), {
    ...options,
    method: 'GET'
  });
};

export type syncLatestReleasesForProductsResponse200 = {
  data: void;
  status: 200;
};

export type syncLatestReleasesForProductsResponseSuccess = syncLatestReleasesForProductsResponse200 & {
  headers: Headers;
};
export type syncLatestReleasesForProductsResponse = syncLatestReleasesForProductsResponseSuccess;

export const getSyncLatestReleasesForProductsUrl = () => {
  return `/api/product-details/sync-release-notes`;
};

export const syncLatestReleasesForProducts = async (options?: RequestInit): Promise<syncLatestReleasesForProductsResponse> => {
  return customFetch<syncLatestReleasesForProductsResponse>(getSyncLatestReleasesForProductsUrl(), {
    ...options,
    method: 'GET'
  });
};

/**
 * get designer installation count by product id
 * @summary Get designer installation count by product id.
 */
export type getProductDesignerInstallationByProductIdResponse200 = {
  data: DesignerInstallation[];
  status: 200;
};

export type getProductDesignerInstallationByProductIdResponseSuccess = getProductDesignerInstallationByProductIdResponse200 & {
  headers: Headers;
};
export type getProductDesignerInstallationByProductIdResponse = getProductDesignerInstallationByProductIdResponseSuccess;

export const getGetProductDesignerInstallationByProductIdUrl = (id: string) => {
  return `/api/product-designer-installation/installation/${id}/designer`;
};

export const getProductDesignerInstallationByProductId = async (
  id: string,
  options?: RequestInit
): Promise<getProductDesignerInstallationByProductIdResponse> => {
  return customFetch<getProductDesignerInstallationByProductIdResponse>(getGetProductDesignerInstallationByProductIdUrl(id), {
    ...options,
    method: 'GET'
  });
};

/**
 * Fetch all GitHub repositories with their details and test results
 * @summary Get all GitHub repositories
 */
export type getGitHubReposResponse200 = {
  data: GithubReposModel[];
  status: 200;
};

export type getGitHubReposResponseSuccess = getGitHubReposResponse200 & {
  headers: Headers;
};
export type getGitHubReposResponse = getGitHubReposResponseSuccess;

export const getGetGitHubReposUrl = () => {
  return `/api/monitor-dashboard/repos`;
};

export const getGitHubRepos = async (options?: RequestInit): Promise<getGitHubReposResponse> => {
  return customFetch<getGitHubReposResponse>(getGetGitHubReposUrl(), {
    ...options,
    method: 'GET'
  });
};

/**
 * Collect the byte[] of image with contentType in header is PNG
 * @summary Get the image content by id
 */
export type findImageByIdResponse200 = {
  data: Image;
  status: 200;
};

export type findImageByIdResponse204 = {
  data: string[];
  status: 204;
};

export type findImageByIdResponse404 = {
  data: string[];
  status: 404;
};

export type findImageByIdResponseSuccess = (findImageByIdResponse200 | findImageByIdResponse204) & {
  headers: Headers;
};
export type findImageByIdResponseError = findImageByIdResponse404 & {
  headers: Headers;
};

export type findImageByIdResponse = findImageByIdResponseSuccess | findImageByIdResponseError;

export const getFindImageByIdUrl = (id: string) => {
  return `/api/image/${id}`;
};

export const findImageById = async (id: string, options?: RequestInit): Promise<findImageByIdResponse> => {
  return customFetch<findImageByIdResponse>(getFindImageByIdUrl(id), {
    ...options,
    method: 'GET'
  });
};

/**
 * Get all feedbacks by product id(from meta.json) which is used in mobile viewport.
 * @summary Find all feedbacks by product id
 */
export type findFeedbackResponse200 = {
  data: FeedbackModel;
  status: 200;
};

export type findFeedbackResponseSuccess = findFeedbackResponse200 & {
  headers: Headers;
};
export type findFeedbackResponse = findFeedbackResponseSuccess;

export const getFindFeedbackUrl = (id: string) => {
  return `/api/feedback/${id}`;
};

export const findFeedback = async (id: string, options?: RequestInit): Promise<findFeedbackResponse> => {
  return customFetch<findFeedbackResponse>(getFindFeedbackUrl(id), {
    ...options,
    method: 'GET'
  });
};

/**
 * Get all user feedback by product id (from meta.json) with lazy loading
 * @summary Find feedbacks by product id with lazy loading
 */
export type findFeedbacksResponse200 = {
  data: PagedModelFeedbackModel;
  status: 200;
};

export type findFeedbacksResponseSuccess = findFeedbacksResponse200 & {
  headers: Headers;
};
export type findFeedbacksResponse = findFeedbacksResponseSuccess;

export const getFindFeedbacksUrl = (id: string, params: FindFeedbacksParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ['sort'];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach(v => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/feedback/product/${id}?${stringifiedParams}` : `/api/feedback/product/${id}`;
};

export const findFeedbacks = async (id: string, params: FindFeedbacksParams, options?: RequestInit): Promise<findFeedbacksResponse> => {
  return customFetch<findFeedbacksResponse>(getFindFeedbacksUrl(id, params), {
    ...options,
    method: 'GET'
  });
};

/**
 * Get overall rating of product by its id.
 * @summary Find rating information of product by its id.
 */
export type getProductRatingResponse200 = {
  data: ProductRating[];
  status: 200;
};

export type getProductRatingResponseSuccess = getProductRatingResponse200 & {
  headers: Headers;
};
export type getProductRatingResponse = getProductRatingResponseSuccess;

export const getGetProductRatingUrl = (id: string) => {
  return `/api/feedback/product/${id}/rating`;
};

export const getProductRating = async (id: string, options?: RequestInit): Promise<getProductRatingResponse> => {
  return customFetch<getProductRatingResponse>(getGetProductRatingUrl(id), {
    ...options,
    method: 'GET'
  });
};

export type findExternalDocumentResponse200 = {
  data: ExternalDocumentModel;
  status: 200;
};

export type findExternalDocumentResponseSuccess = findExternalDocumentResponse200 & {
  headers: Headers;
};
export type findExternalDocumentResponse = findExternalDocumentResponseSuccess;

export const getFindExternalDocumentUrl = (id: string, version: string) => {
  return `/api/externaldocument/${id}/${version}`;
};

export const findExternalDocument = async (id: string, version: string, options?: RequestInit): Promise<findExternalDocumentResponse> => {
  return customFetch<findExternalDocumentResponse>(getFindExternalDocumentUrl(id, version), {
    ...options,
    method: 'GET'
  });
};

export type redirectToBestVersionResponse200 = {
  data: void;
  status: 200;
};

export type redirectToBestVersionResponseSuccess = redirectToBestVersionResponse200 & {
  headers: Headers;
};
export type redirectToBestVersionResponse = redirectToBestVersionResponseSuccess;

export const getRedirectToBestVersionUrl = (params?: RedirectToBestVersionParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/externaldocument/best-match?${stringifiedParams}` : `/api/externaldocument/best-match`;
};

export const redirectToBestVersion = async (
  params?: RedirectToBestVersionParams,
  options?: RequestInit
): Promise<redirectToBestVersionResponse> => {
  return customFetch<redirectToBestVersionResponse>(getRedirectToBestVersionUrl(params), {
    ...options,
    method: 'GET'
  });
};

export type getDocumentByVersionAndLanguageResponse200 = {
  data: DocumentInfoResponse;
  status: 200;
};

export type getDocumentByVersionAndLanguageResponseSuccess = getDocumentByVersionAndLanguageResponse200 & {
  headers: Headers;
};
export type getDocumentByVersionAndLanguageResponse = getDocumentByVersionAndLanguageResponseSuccess;

export const getGetDocumentByVersionAndLanguageUrl = (artifact: string, version: string, language: string) => {
  return `/api/docs/${artifact}/${version}/${language}`;
};

export const getDocumentByVersionAndLanguage = async (
  artifact: string,
  version: string,
  language: string,
  options?: RequestInit
): Promise<getDocumentByVersionAndLanguageResponse> => {
  return customFetch<getDocumentByVersionAndLanguageResponse>(getGetDocumentByVersionAndLanguageUrl(artifact, version, language), {
    ...options,
    method: 'GET'
  });
};
