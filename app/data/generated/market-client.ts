/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import { customFetch } from '../custom-fetch';
export interface FeedbackModelRequest {
  /** Product id (from meta.json) */
  productId: string;
  /**
   * User's feedback content
   * @minLength 0
   * @maxLength 250
   */
  content: string;
  /**
   * User's rating point of target product
   * @minimum 1
   * @maximum 5
   */
  rating?: number;
}

export interface Links {
  [key: string]: Link;
}

export interface PageMetadata {
  size?: number;
  totalElements?: number;
  totalPages?: number;
  number?: number;
}

export type _PagedModelProductModelEmbedded = {
  products?: ProductModel[];
};

export interface PagedModelProductModel {
  _embedded?: _PagedModelProductModelEmbedded;
  _links?: Links;
  page?: PageMetadata;
}

/**
 * Product name by locale
 */
export type ProductModelNames = { [key: string]: string };

/**
 * Product's short descriptions by locale
 */
export type ProductModelShortDescriptions = { [key: string]: string };

export interface ProductModel {
  /** Product id */
  id?: string;
  /** Product name by locale */
  names?: ProductModelNames;
  /** Product's short descriptions by locale */
  shortDescriptions?: ProductModelShortDescriptions;
  /** Product's logo url */
  logoUrl?: string;
  /** Type of product */
  type?: string;
  /** Tags of product */
  tags?: string[];
  _links?: Links;
}

export interface GitHubReleaseModel {
  /** Version of release */
  name?: string;
  /** Body of release */
  body?: string;
  /** Published date of release */
  publishedAt?: string;
  /** Link of release */
  htmlUrl?: string;
  latestRelease?: boolean;
  _links?: Links;
}

/**
 * Product name by locale
 */
export type ProductDetailModelNames = { [key: string]: string };

/**
 * Product's short descriptions by locale
 */
export type ProductDetailModelShortDescriptions = { [key: string]: string };

export interface ProductDetailModel {
  /** Product id */
  id?: string;
  /** Product name by locale */
  names?: ProductDetailModelNames;
  /** Product's short descriptions by locale */
  shortDescriptions?: ProductDetailModelShortDescriptions;
  /** Product's logo url */
  logoUrl?: string;
  /** Type of product */
  type?: string;
  /** Tags of product */
  tags?: string[];
  /** Product vendor */
  vendor?: string;
  /** Product vendor url */
  vendorUrl?: string;
  /** Product vendor image */
  vendorImage?: string;
  /** Product vendor image dark mode */
  vendorImageDarkMode?: string;
  /** Platform review */
  platformReview?: string;
  /** Latest release version from maven */
  newestReleaseVersion?: string;
  /** Product cost */
  cost?: string;
  /** Source repository url */
  sourceUrl?: string;
  /** Status badge url */
  statusBadgeUrl?: string;
  /** Default language */
  language?: string;
  /** Product industry */
  industry?: string;
  /** Compatibility */
  compatibility?: string;
  /** Can contact us */
  contactUs?: boolean;
  productModuleContent?: ProductModuleContent;
  /** Installation/download count */
  installationCount?: number;
  /** The api url to get metadata from product.json */
  metaProductJsonUrl?: string;
  compatibilityRange?: string;
  mavenDropins?: boolean;
  _links?: Links;
}

/**
 * Product detail description content
 */
export type ProductModuleContentDescription = { [key: string]: string };

/**
 * Setup tab content
 */
export type ProductModuleContentSetup = { [key: string]: string };

/**
 * Demo tab content
 */
export type ProductModuleContentDemo = { [key: string]: string };

export interface ProductModuleContent {
  id?: string;
  /** product Id (from meta.json) */
  productId?: string;
  /** Maven version */
  version?: string;
  /** Product detail description content  */
  description?: ProductModuleContentDescription;
  /** Setup tab content */
  setup?: ProductModuleContentSetup;
  /** Demo tab content */
  demo?: ProductModuleContentDemo;
  /** Is dependency artifact */
  isDependency?: boolean;
  name?: string;
  /** Product artifact's group id */
  groupId?: string;
  /** Product artifact's artifact id */
  artifactId?: string;
  /** Artifact file type */
  type?: string;
  updatedAt?: string;
}

export interface MavenArtifactModel {
  /** Display name and type of artifact */
  name?: string;
  /** Artifact download url */
  downloadUrl?: string;
  artifactId?: string;
}

export interface MavenArtifactVersionModel {
  /** Target version */
  version?: string;
  artifactsByVersion?: MavenArtifactModel[];
}

export type _PagedModelGitHubReleaseModelEmbedded = {
  gitHubReleaseModelList?: GitHubReleaseModel[];
};

export interface PagedModelGitHubReleaseModel {
  _embedded?: _PagedModelGitHubReleaseModelEmbedded;
  _links?: Links;
  page?: PageMetadata;
}

export interface VersionAndUrlModel {
  version?: string;
  url?: string;
}

export interface ResponseBodyEmitter {
  timeout?: number;
}

export interface DesignerInstallation {
  /** Ivy designer version */
  designerVersion?: string;
  numberOfDownloads?: number;
}

/**
 * The image content as binary type
 */
export interface Binary {
  type?: string;
  data?: string[];
}

export interface Image {
  id?: string;
  /** Product id */
  productId?: string;
  /** The download url from github */
  imageUrl?: string;
  imageData?: Binary;
  /** The SHA from github */
  sha?: string;
}

export interface FeedbackModel {
  /** Id of feedback */
  id?: string;
  /** User Id */
  userId?: string;
  /** Github username */
  username?: string;
  /** Url of github avatar */
  userAvatarUrl?: string;
  /** 3rd party login provider */
  userProvider?: string;
  /** Product id (from meta.json) */
  productId?: string;
  /** User's feedback content */
  content?: string;
  /**
   * User's rating point of target product
   * @minimum 1
   * @maximum 5
   */
  rating?: number;
  /** Feedback/rating creating timestamp */
  createdAt?: string;
  /** Latest feedback/rating updating timestamp */
  updatedAt?: string;
  _links?: Links;
}

export type _PagedModelFeedbackModelEmbedded = {
  feedbacks?: FeedbackModel[];
};

export interface PagedModelFeedbackModel {
  _embedded?: _PagedModelFeedbackModelEmbedded;
  _links?: Links;
  page?: PageMetadata;
}

export interface ProductRating {
  /** Specific rating point of product */
  starRating?: number;
  /** Count of rating on this specific point */
  commentNumber?: number;
  /** Weight ration of this point/ total point */
  percent?: number;
}

export interface ExternalDocumentModel {
  /** Product id */
  productId?: string;
  /** Name of artifact */
  artifactName?: string;
  /** Version of artifact */
  version?: string;
  /** Relative link of document page */
  relativeLink?: string;
  _links?: Links;
}

export interface Link {
  href?: string;
  hreflang?: string;
  title?: string;
  type?: string;
  deprecation?: string;
  profile?: string;
  name?: string;
  templated?: boolean;
}

export type FindFeedbackByUserIdAndProductIdParams = {
  /**
   * Id of current user from DB
   */
  userId: string;
  /**
   * Product id (from meta.json)
   */
  productId: string;
};

export type FindProductsParams = {
  /**
   * Page number to retrieve
   */
  page: number;
  /**
   * Number of items per page
   */
  size?: number;
  /**
   * Sorting criteria in the format: Sorting criteria(popularity|alphabetically|recent), Sorting order(asc|desc)
   */
  sort: string[];
  /**
   * Type of product.
   */
  type: FindProductsType;
  /**
   * Keyword that exist in product's name or short description
   */
  keyword?: string;
  /**
   * Language of product short description
   */
  language: FindProductsLanguage;
  /**
   * Option to render the website in the REST Client Editor of Designer
   */
  isRESTClient: boolean;
};

export type FindProductsType = (typeof FindProductsType)[keyof typeof FindProductsType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FindProductsType = {
  all: 'all',
  connectors: 'connectors',
  utilities: 'utilities',
  solutions: 'solutions',
  demos: 'demos'
} as const;

export type FindProductsLanguage = (typeof FindProductsLanguage)[keyof typeof FindProductsLanguage];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FindProductsLanguage = {
  en: 'en',
  de: 'de'
} as const;

export type FindProductDetailsParams = {
  /**
   * Option to get Dev Version (Snapshot/ sprint release)
   */
  isShowDevVersion?: boolean;
};

export type FindProductJsonContent200 = { [key: string]: { [key: string]: unknown } };

export type FindProductVersionsByIdParams = {
  /**
   * Option to get Dev Version (Snapshot/ sprint release)
   */
  isShowDevVersion: boolean;
  designerVersion?: string;
};

export type FindGithubPublicReleasesParams = {
  /**
   * Page number to retrieve
   */
  page: number;
  /**
   * Number of items per page
   */
  size?: number;
  /**
   * Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   */
  sort?: string[];
};

export type GetLatestArtifactDownloadUrlParams = {
  version: string;
  artifact: string;
};

export type DownloadZipArtifactParams = {
  version: string;
  artifact: string;
};

export type FindFeedbacksParams = {
  /**
   * Page number to retrieve
   */
  page: number;
  /**
   * Number of items per page
   */
  size?: number;
  /**
   * Sorting criteria in the format: Sorting criteria(popularity|alphabetically|recent), Sorting order(asc|desc)
   */
  sort: string[];
};

/**
 * Get current user feedback on target product.
 * @summary Find all feedbacks by user id and product id
 */
export type findFeedbackByUserIdAndProductIdResponse200 = {
  data: FeedbackModel;
  status: 200;
};

export type findFeedbackByUserIdAndProductIdResponseComposite = findFeedbackByUserIdAndProductIdResponse200;

export type findFeedbackByUserIdAndProductIdResponse = findFeedbackByUserIdAndProductIdResponseComposite & {
  headers: Headers;
};

export const getFindFeedbackByUserIdAndProductIdUrl = (params: FindFeedbackByUserIdAndProductIdParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/feedback?${stringifiedParams}` : `/api/feedback`;
};

export const findFeedbackByUserIdAndProductId = async (
  params: FindFeedbackByUserIdAndProductIdParams,
  options?: RequestInit
): Promise<findFeedbackByUserIdAndProductIdResponse> => {
  return customFetch<findFeedbackByUserIdAndProductIdResponse>(getFindFeedbackByUserIdAndProductIdUrl(params), {
    ...options,
    method: 'GET'
  });
};

/**
 * Save user feedback of product with their token from Github account.
 * @summary Create user feedback
 */
export type createFeedbackResponse201 = {
  data: void;
  status: 201;
};

export type createFeedbackResponse401 = {
  data: void;
  status: 401;
};

export type createFeedbackResponseComposite = createFeedbackResponse201 | createFeedbackResponse401;

export type createFeedbackResponse = createFeedbackResponseComposite & {
  headers: Headers;
};

export const getCreateFeedbackUrl = () => {
  return `/api/feedback`;
};

export const createFeedback = async (
  feedbackModelRequest: FeedbackModelRequest,
  options?: RequestInit
): Promise<createFeedbackResponse> => {
  return customFetch<createFeedbackResponse>(getCreateFeedbackUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(feedbackModelRequest)
  });
};

/**
 * By default, the system finds products with type 'all'
 * @summary Retrieve a paginated list of all products, optionally filtered by type, keyword, and language
 */
export type findProductsResponse200 = {
  data: PagedModelProductModel;
  status: 200;
};

export type findProductsResponseComposite = findProductsResponse200;

export type findProductsResponse = findProductsResponseComposite & {
  headers: Headers;
};

export const getFindProductsUrl = (params: FindProductsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/product?${stringifiedParams}` : `/api/product`;
};

export const findProducts = async (params: FindProductsParams, options?: RequestInit): Promise<findProductsResponse> => {
  return customFetch<findProductsResponse>(getFindProductsUrl(params), {
    ...options,
    method: 'GET'
  });
};

/**
 * Get release by product id and release id
 * @summary Find release by product id and release id
 */
export type findGithubPublicReleaseByProductIdAndReleaseIdResponse200 = {
  data: GitHubReleaseModel;
  status: 200;
};

export type findGithubPublicReleaseByProductIdAndReleaseIdResponseComposite = findGithubPublicReleaseByProductIdAndReleaseIdResponse200;

export type findGithubPublicReleaseByProductIdAndReleaseIdResponse = findGithubPublicReleaseByProductIdAndReleaseIdResponseComposite & {
  headers: Headers;
};

export const getFindGithubPublicReleaseByProductIdAndReleaseIdUrl = (productId: string, releaseId: number) => {
  return `/api/product-details/${productId}/releases/${releaseId}`;
};

export const findGithubPublicReleaseByProductIdAndReleaseId = async (
  productId: string,
  releaseId: number,
  options?: RequestInit
): Promise<findGithubPublicReleaseByProductIdAndReleaseIdResponse> => {
  return customFetch<findGithubPublicReleaseByProductIdAndReleaseIdResponse>(
    getFindGithubPublicReleaseByProductIdAndReleaseIdUrl(productId, releaseId),
    {
      ...options,
      method: 'GET'
    }
  );
};

/**
 * Return product detail by product id (from meta.json)
 * @summary get product detail by ID
 */
export type findProductDetailsResponse200 = {
  data: ProductDetailModel;
  status: 200;
};

export type findProductDetailsResponseComposite = findProductDetailsResponse200;

export type findProductDetailsResponse = findProductDetailsResponseComposite & {
  headers: Headers;
};

export const getFindProductDetailsUrl = (id: string, params?: FindProductDetailsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/product-details/${id}?${stringifiedParams}` : `/api/product-details/${id}`;
};

export const findProductDetails = async (
  id: string,
  params?: FindProductDetailsParams,
  options?: RequestInit
): Promise<findProductDetailsResponse> => {
  return customFetch<findProductDetailsResponse>(getFindProductDetailsUrl(id, params), {
    ...options,
    method: 'GET'
  });
};

/**
 * get product detail by it product id and release version
 * @summary Find product detail by product id and release version.
 */
export type findProductDetailsByVersionResponse200 = {
  data: ProductDetailModel;
  status: 200;
};

export type findProductDetailsByVersionResponseComposite = findProductDetailsByVersionResponse200;

export type findProductDetailsByVersionResponse = findProductDetailsByVersionResponseComposite & {
  headers: Headers;
};

export const getFindProductDetailsByVersionUrl = (id: string, version: string) => {
  return `/api/product-details/${id}/${version}`;
};

export const findProductDetailsByVersion = async (
  id: string,
  version: string,
  options?: RequestInit
): Promise<findProductDetailsByVersionResponse> => {
  return customFetch<findProductDetailsByVersionResponse>(getFindProductDetailsByVersionUrl(id, version), {
    ...options,
    method: 'GET'
  });
};

/**
 * When we click install in designer, this API will send content of product json for installing in Ivy designer
 * @summary Get product json content for designer to install
 */
export type findProductJsonContentResponse200 = {
  data: FindProductJsonContent200;
  status: 200;
};

export type findProductJsonContentResponseComposite = findProductJsonContentResponse200;

export type findProductJsonContentResponse = findProductJsonContentResponseComposite & {
  headers: Headers;
};

export const getFindProductJsonContentUrl = (id: string, version: string) => {
  return `/api/product-details/${id}/${version}/json`;
};

export const findProductJsonContent = async (
  id: string,
  version: string,
  options?: RequestInit
): Promise<findProductJsonContentResponse> => {
  return customFetch<findProductJsonContentResponse>(getFindProductJsonContentUrl(id, version), {
    ...options,
    method: 'GET'
  });
};

/**
 * get product detail by it product id and version
 * @summary Find best match product detail by product id and version.
 */
export type findBestMatchProductDetailsByVersionResponse200 = {
  data: ProductDetailModel;
  status: 200;
};

export type findBestMatchProductDetailsByVersionResponseComposite = findBestMatchProductDetailsByVersionResponse200;

export type findBestMatchProductDetailsByVersionResponse = findBestMatchProductDetailsByVersionResponseComposite & {
  headers: Headers;
};

export const getFindBestMatchProductDetailsByVersionUrl = (id: string, version: string) => {
  return `/api/product-details/${id}/${version}/bestmatch`;
};

export const findBestMatchProductDetailsByVersion = async (
  id: string,
  version: string,
  options?: RequestInit
): Promise<findBestMatchProductDetailsByVersionResponse> => {
  return customFetch<findBestMatchProductDetailsByVersionResponse>(getFindBestMatchProductDetailsByVersionUrl(id, version), {
    ...options,
    method: 'GET'
  });
};

export type findProductVersionsByIdResponse200 = {
  data: MavenArtifactVersionModel[];
  status: 200;
};

export type findProductVersionsByIdResponseComposite = findProductVersionsByIdResponse200;

export type findProductVersionsByIdResponse = findProductVersionsByIdResponseComposite & {
  headers: Headers;
};

export const getFindProductVersionsByIdUrl = (id: string, params: FindProductVersionsByIdParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/product-details/${id}/versions?${stringifiedParams}` : `/api/product-details/${id}/versions`;
};

export const findProductVersionsById = async (
  id: string,
  params: FindProductVersionsByIdParams,
  options?: RequestInit
): Promise<findProductVersionsByIdResponse> => {
  return customFetch<findProductVersionsByIdResponse>(getFindProductVersionsByIdUrl(id, params), {
    ...options,
    method: 'GET'
  });
};

/**
 * Get all public releases by product id
 * @summary Find public releases by product id
 */
export type findGithubPublicReleasesResponse200 = {
  data: PagedModelGitHubReleaseModel;
  status: 200;
};

export type findGithubPublicReleasesResponseComposite = findGithubPublicReleasesResponse200;

export type findGithubPublicReleasesResponse = findGithubPublicReleasesResponseComposite & {
  headers: Headers;
};

export const getFindGithubPublicReleasesUrl = (id: string, params: FindGithubPublicReleasesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/product-details/${id}/releases?${stringifiedParams}` : `/api/product-details/${id}/releases`;
};

export const findGithubPublicReleases = async (
  id: string,
  params: FindGithubPublicReleasesParams,
  options?: RequestInit
): Promise<findGithubPublicReleasesResponse> => {
  return customFetch<findGithubPublicReleasesResponse>(getFindGithubPublicReleasesUrl(id, params), {
    ...options,
    method: 'GET'
  });
};

/**
 * Collect the released versions in product for ivy designer
 * @summary Get the list of released version in product
 */
export type findVersionsForDesignerResponse200 = {
  data: VersionAndUrlModel[];
  status: 200;
};

export type findVersionsForDesignerResponseComposite = findVersionsForDesignerResponse200;

export type findVersionsForDesignerResponse = findVersionsForDesignerResponseComposite & {
  headers: Headers;
};

export const getFindVersionsForDesignerUrl = (id: string) => {
  return `/api/product-details/${id}/designerversions`;
};

export const findVersionsForDesigner = async (id: string, options?: RequestInit): Promise<findVersionsForDesignerResponse> => {
  return customFetch<findVersionsForDesignerResponse>(getFindVersionsForDesignerUrl(id), {
    ...options,
    method: 'GET'
  });
};

/**
 * Return the download url of artifact from version and id
 * @summary Get the download url of latest version from artifact by its id and target version
 */
export type getLatestArtifactDownloadUrlResponse200 = {
  data: string;
  status: 200;
};

export type getLatestArtifactDownloadUrlResponseComposite = getLatestArtifactDownloadUrlResponse200;

export type getLatestArtifactDownloadUrlResponse = getLatestArtifactDownloadUrlResponseComposite & {
  headers: Headers;
};

export const getGetLatestArtifactDownloadUrlUrl = (id: string, params: GetLatestArtifactDownloadUrlParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/product-details/${id}/artifact?${stringifiedParams}` : `/api/product-details/${id}/artifact`;
};

export const getLatestArtifactDownloadUrl = async (
  id: string,
  params: GetLatestArtifactDownloadUrlParams,
  options?: RequestInit
): Promise<getLatestArtifactDownloadUrlResponse> => {
  return customFetch<getLatestArtifactDownloadUrlResponse>(getGetLatestArtifactDownloadUrlUrl(id, params), {
    ...options,
    method: 'GET'
  });
};

/**
 * Return the download url of artifact from version and id
 * @summary Get the download steam of artifact and it's dependencies by it's id and target version
 */
export type downloadZipArtifactResponse200 = {
  data: ResponseBodyEmitter;
  status: 200;
};

export type downloadZipArtifactResponseComposite = downloadZipArtifactResponse200;

export type downloadZipArtifactResponse = downloadZipArtifactResponseComposite & {
  headers: Headers;
};

export const getDownloadZipArtifactUrl = (id: string, params: DownloadZipArtifactParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/product-details/${id}/artifact/zip-file?${stringifiedParams}`
    : `/api/product-details/${id}/artifact/zip-file`;
};

export const downloadZipArtifact = async (
  id: string,
  params: DownloadZipArtifactParams,
  options?: RequestInit
): Promise<downloadZipArtifactResponse> => {
  return customFetch<downloadZipArtifactResponse>(getDownloadZipArtifactUrl(id, params), {
    ...options,
    method: 'GET'
  });
};

export type syncLatestReleasesForProductsResponse200 = {
  data: void;
  status: 200;
};

export type syncLatestReleasesForProductsResponseComposite = syncLatestReleasesForProductsResponse200;

export type syncLatestReleasesForProductsResponse = syncLatestReleasesForProductsResponseComposite & {
  headers: Headers;
};

export const getSyncLatestReleasesForProductsUrl = () => {
  return `/api/product-details/sync-release-notes`;
};

export const syncLatestReleasesForProducts = async (options?: RequestInit): Promise<syncLatestReleasesForProductsResponse> => {
  return customFetch<syncLatestReleasesForProductsResponse>(getSyncLatestReleasesForProductsUrl(), {
    ...options,
    method: 'GET'
  });
};

/**
 * get designer installation count by product id
 * @summary Get designer installation count by product id.
 */
export type getProductDesignerInstallationByProductIdResponse200 = {
  data: DesignerInstallation[];
  status: 200;
};

export type getProductDesignerInstallationByProductIdResponseComposite = getProductDesignerInstallationByProductIdResponse200;

export type getProductDesignerInstallationByProductIdResponse = getProductDesignerInstallationByProductIdResponseComposite & {
  headers: Headers;
};

export const getGetProductDesignerInstallationByProductIdUrl = (id: string) => {
  return `/api/product-designer-installation/installation/${id}/designer`;
};

export const getProductDesignerInstallationByProductId = async (
  id: string,
  options?: RequestInit
): Promise<getProductDesignerInstallationByProductIdResponse> => {
  return customFetch<getProductDesignerInstallationByProductIdResponse>(getGetProductDesignerInstallationByProductIdUrl(id), {
    ...options,
    method: 'GET'
  });
};

/**
 * Collect the byte[] of image with contentType in header is PNG
 * @summary Get the image content by id
 */
export type findImageByIdResponse200 = {
  data: Image;
  status: 200;
};

export type findImageByIdResponse204 = {
  data: string[];
  status: 204;
};

export type findImageByIdResponse404 = {
  data: string[];
  status: 404;
};

export type findImageByIdResponseComposite = findImageByIdResponse200 | findImageByIdResponse204 | findImageByIdResponse404;

export type findImageByIdResponse = findImageByIdResponseComposite & {
  headers: Headers;
};

export const getFindImageByIdUrl = (id: string) => {
  return `/api/image/${id}`;
};

export const findImageById = async (id: string, options?: RequestInit): Promise<findImageByIdResponse> => {
  return customFetch<findImageByIdResponse>(getFindImageByIdUrl(id), {
    ...options,
    method: 'GET'
  });
};

/**
 * Get all feedbacks by product id(from meta.json) which is used in mobile viewport.
 * @summary Find all feedbacks by product id
 */
export type findFeedbackResponse200 = {
  data: FeedbackModel;
  status: 200;
};

export type findFeedbackResponseComposite = findFeedbackResponse200;

export type findFeedbackResponse = findFeedbackResponseComposite & {
  headers: Headers;
};

export const getFindFeedbackUrl = (id: string) => {
  return `/api/feedback/${id}`;
};

export const findFeedback = async (id: string, options?: RequestInit): Promise<findFeedbackResponse> => {
  return customFetch<findFeedbackResponse>(getFindFeedbackUrl(id), {
    ...options,
    method: 'GET'
  });
};

/**
 * Get all user feedback by product id (from meta.json) with lazy loading
 * @summary Find feedbacks by product id with lazy loading
 */
export type findFeedbacksResponse200 = {
  data: PagedModelFeedbackModel;
  status: 200;
};

export type findFeedbacksResponseComposite = findFeedbacksResponse200;

export type findFeedbacksResponse = findFeedbacksResponseComposite & {
  headers: Headers;
};

export const getFindFeedbacksUrl = (id: string, params: FindFeedbacksParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/feedback/product/${id}?${stringifiedParams}` : `/api/feedback/product/${id}`;
};

export const findFeedbacks = async (id: string, params: FindFeedbacksParams, options?: RequestInit): Promise<findFeedbacksResponse> => {
  return customFetch<findFeedbacksResponse>(getFindFeedbacksUrl(id, params), {
    ...options,
    method: 'GET'
  });
};

/**
 * Get overall rating of product by its id.
 * @summary Find rating information of product by its id.
 */
export type getProductRatingResponse200 = {
  data: ProductRating[];
  status: 200;
};

export type getProductRatingResponseComposite = getProductRatingResponse200;

export type getProductRatingResponse = getProductRatingResponseComposite & {
  headers: Headers;
};

export const getGetProductRatingUrl = (id: string) => {
  return `/api/feedback/product/${id}/rating`;
};

export const getProductRating = async (id: string, options?: RequestInit): Promise<getProductRatingResponse> => {
  return customFetch<getProductRatingResponse>(getGetProductRatingUrl(id), {
    ...options,
    method: 'GET'
  });
};

export type findExternalDocumentResponse200 = {
  data: ExternalDocumentModel;
  status: 200;
};

export type findExternalDocumentResponseComposite = findExternalDocumentResponse200;

export type findExternalDocumentResponse = findExternalDocumentResponseComposite & {
  headers: Headers;
};

export const getFindExternalDocumentUrl = (id: string, version: string) => {
  return `/api/externaldocument/${id}/${version}`;
};

export const findExternalDocument = async (id: string, version: string, options?: RequestInit): Promise<findExternalDocumentResponse> => {
  return customFetch<findExternalDocumentResponse>(getFindExternalDocumentUrl(id, version), {
    ...options,
    method: 'GET'
  });
};
