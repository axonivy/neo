/**
 * Generated by orval v7.17.2 ðŸº
 * Do not edit manually.
 * Axon Ivy OpenAPI
 */
import { customFetch } from '../custom-fetch';
export type WebNotificationOperationOperation = typeof WebNotificationOperationOperation[keyof typeof WebNotificationOperationOperation];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WebNotificationOperationOperation = {
  MARK_AS_READ: 'MARK_AS_READ',
} as const;

export interface WebNotificationOperation {
  operation?: WebNotificationOperationOperation;
}

export interface WebNotificationActionBean {
  link?: string;
  title?: string;
}

export interface WebNotificationBean {
  uuid?: string;
  createdAt?: string;
  read?: boolean;
  message?: string;
  details?: WebNotificationActionBean;
  start?: WebNotificationActionBean;
}

export interface UserBean {
  uuid?: string;
  name?: string;
  fullName?: string;
  emailAddress?: string;
  language?: string;
}

export interface EngineInfo {
  version?: string;
  engineName?: string;
  minimumSupportedMobileAppVersion?: string;
}

export interface ConfigurationIdentifier {
  path: string;
  project: ProjectIdentifier;
}

export interface ProjectIdentifier {
  app: string;
  pmv: string;
  isIar?: boolean;
}

export interface ConfigurationBean {
  id: ConfigurationIdentifier;
  content: string;
}

export interface DataClassBean {
  name: string;
  simpleName: string;
  dataClassIdentifier: DataClassIdentifier;
  path: string;
  fields: DataClassField[];
  isEntityClass: boolean;
  isBusinessCaseData: boolean;
}

export interface DataClassField {
  name: string;
  type: string;
}

export interface DataClassIdentifier {
  project: ProjectIdentifier;
  name: string;
}

export interface DataClassInit {
  name: string;
  project?: ProjectIdentifier;
  projectDir?: string;
}

export interface FormIdentifier {
  project: ProjectIdentifier;
  id: string;
}

export interface HdBean {
  identifier: FormIdentifier;
  name: string;
  namespace?: string;
  path: string;
  type?: string;
  uri?: string;
}

export interface HdInit {
  namespace: string;
  name: string;
  type?: string;
  template?: string;
  layout?: string;
  projectDir?: string;
  pid?: string;
  project?: ProjectIdentifier;
  dataClass?: DataClassIdentifier;
}

export type ProcessBeanKind = typeof ProcessBeanKind[keyof typeof ProcessBeanKind];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProcessBeanKind = {
  NORMAL: 'NORMAL',
  WEB_SERVICE: 'WEB_SERVICE',
  CALLABLE_SUB: 'CALLABLE_SUB',
  HTML_DIALOG: 'HTML_DIALOG',
} as const;

export interface ProcessBean {
  name: string;
  namespace: string;
  processIdentifier: ProcessIdentifier;
  path?: string;
  requestPath?: string;
  processGroup?: string;
  kind: ProcessBeanKind;
  type?: string;
  uri?: string;
}

export interface ProcessIdentifier {
  project: ProjectIdentifier;
  pid: string;
}

export interface ProcessInit {
  name: string;
  namespace: string;
  path?: string;
  kind: string;
  pid?: string;
  project?: ProjectIdentifier;
}

export interface ProjectBean {
  artifactId: string;
  groupId: string;
  id: ProjectIdentifier;
  version: string;
  isDeletable: boolean;
  defaultNamespace: string;
  projectDirectory: string;
  dependencies: ProjectIdentifier[];
  errorMessage: string;
}

export interface NewProjectParams {
  name: string;
  groupId: string;
  projectId: string;
  path?: string;
}

export interface ProjectParams {
  name?: string;
  path?: string;
}

export interface WorkspaceBean {
  id: string;
  name: string;
  baseUrl: string;
  running: boolean;
}

export interface WorkspaceInit {
  name: string;
  path?: string;
  neo?: boolean;
}

export interface MarketInstallResult {
  installedProjects: ProjectIdentifier[];
  demoProcesses: ProcessBean[];
}

export interface ProductInstallParams {
  productJson: string;
  dependentProject?: ProjectIdentifier;
  dependentProjectPath?: string;
}

export interface AggBean { [key: string]: unknown }

export interface DocumentBean {
  id?: number;
  name?: string;
  url?: string;
  path?: string;
}

export interface MessageBean {
  message?: string;
  statusCode?: number;
  document?: DocumentBean;
}

export interface ProcessStartBean {
  id?: number;
  name?: string;
  description?: string;
  activatorName?: string;
  fullRequestPath?: string;
}

export interface StartCustomFieldBean {
  name?: string;
  value?: string;
}

export interface WebStartableBean {
  id?: string;
  name?: string;
  description?: string;
  activatorName?: string;
  roles?: string[];
  fullRequestPath?: string;
  customFields?: StartCustomFieldBean[];
}

export interface CaseBean {
  id?: number;
  name?: string;
  description?: string;
  documents?: DocumentBean[];
}

export interface ResponsibleBean {
  name?: string;
}

export interface TaskBean {
  id?: number;
  name?: string;
  description?: string;
  startTimeStamp?: string;
  expiryTimeStamp?: string;
  priority?: number;
  state?: number;
  activatorName?: string;
  responsibles?: ResponsibleBean[];
  fullRequestPath?: string;
  offline?: boolean;
  case?: CaseBean;
}

/**
 * The geographic coordinate of the location
 */
export interface GeoPositionBean {
  /** Latitute in degree (south) -90.0d..+90.0d (north) */
  latitude?: number;
  /** Longitude in degree (west) -180.0d..+180.0d (east) */
  longitude?: number;
  /** Altitude in meters */
  altitude?: number;
}

export interface LocationBean {
  /** The name of the location, e.g., Zug, Wien */
  name?: string;
  /** The type of the location, e.g., UserPosition, HeadQuarter, BranchOffice */
  type?: string;
  /** Additional note */
  note?: string;
  /** The address of the location, e.g., Baarerstrasse 12;6403 Zug;Switzerland */
  address?: string;
  /** The timestamp when the location was created or updated */
  timestamp?: string;
  position?: GeoPositionBean;
}

export type SetParams = {
/**
 * new value for config
 */
value?: string;
};

export type Set1Params = {
/**
 * new value for config
 */
value?: string;
};

export type Set2Params = {
/**
 * new value for variable
 */
value?: string;
};

export type DeployBody = {
  /** project .iar file or multiple projects in a .zip file */
  fileToDeploy: Blob;
  /** deployment options as YAML file. If defined, the specific params below will be ignored. */
  deploymentOptions?: string;
  deployTestUsers?: string;
  targetVersion?: string;
  targetState?: string;
};

export type ReadConfigParams = {
path?: string;
app?: string;
pmv?: string;
};

export type DataClassesParams = {
withFields?: boolean;
};

export type ComponentFormParams = {
componentId?: string;
app?: string;
pmv?: string;
};

export type ImportProcessBody = {
  app?: string;
  pmv?: string;
  projectDir?: string;
  file?: Blob;
};

export type ProjectsParams = {
withDependencies?: boolean;
};

export type ConvertProjectParams = {
projectDir?: string;
app?: string;
pmv?: string;
};

export type DeleteProjectParams = {
projectDir?: string;
app?: string;
pmv?: string;
};

export type StopBpmEngineParams = {
app?: string;
pmv?: string;
projectDir?: string;
};

export type ImportProjectsBody = {
  file?: Blob;
  dependentProject?: Blob;
};

/**
 * Returns all cluster nodes of where this node is part of.
 */
export type nodesResponse200 = {
  data: void
  status: 200
}

export type nodesResponse401 = {
  data: void
  status: 401
}
    
export type nodesResponseSuccess = (nodesResponse200) & {
  headers: Headers;
};
export type nodesResponseError = (nodesResponse401) & {
  headers: Headers;
};

export type nodesResponse = (nodesResponseSuccess | nodesResponseError)

export const getNodesUrl = () => {


  

  return `/cluster/nodes`
}

export const nodes = async ( options?: RequestInit): Promise<nodesResponse> => {
  
  return customFetch<nodesResponse>(getNodesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Returns the value of the config with the given name.
 */
export type getResponse200 = {
  data: void
  status: 200
}

export type getResponse401 = {
  data: void
  status: 401
}

export type getResponse404 = {
  data: void
  status: 404
}
    
export type getResponseSuccess = (getResponse200) & {
  headers: Headers;
};
export type getResponseError = (getResponse401 | getResponse404) & {
  headers: Headers;
};

export type getResponse = (getResponseSuccess | getResponseError)

export const getGetUrl = (applicationName: string,
    configKey: string,) => {


  

  return `/apps/${applicationName}/configs/${configKey}`
}

export const get = async (applicationName: string,
    configKey: string, options?: RequestInit): Promise<getResponse> => {
  
  return customFetch<getResponse>(getGetUrl(applicationName,configKey),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Sets a new value for the config with the given name.
 */
export type setResponse200 = {
  data: void
  status: 200
}

export type setResponse401 = {
  data: void
  status: 401
}

export type setResponse404 = {
  data: void
  status: 404
}
    
export type setResponseSuccess = (setResponse200) & {
  headers: Headers;
};
export type setResponseError = (setResponse401 | setResponse404) & {
  headers: Headers;
};

export type setResponse = (setResponseSuccess | setResponseError)

export const getSetUrl = (applicationName: string,
    configKey: string,
    params?: SetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/apps/${applicationName}/configs/${configKey}?${stringifiedParams}` : `/apps/${applicationName}/configs/${configKey}`
}

export const set = async (applicationName: string,
    configKey: string,
    setBody: string,
    params?: SetParams, options?: RequestInit): Promise<setResponse> => {
  
  return customFetch<setResponse>(getSetUrl(applicationName,configKey,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': '*/*', ...options?.headers },
    body: JSON.stringify(
      setBody,)
  }
);}



/**
 * Resets the config with the given name to the default value.
 */
export type resetResponse200 = {
  data: void
  status: 200
}

export type resetResponse401 = {
  data: void
  status: 401
}

export type resetResponse404 = {
  data: void
  status: 404
}
    
export type resetResponseSuccess = (resetResponse200) & {
  headers: Headers;
};
export type resetResponseError = (resetResponse401 | resetResponse404) & {
  headers: Headers;
};

export type resetResponse = (resetResponseSuccess | resetResponseError)

export const getResetUrl = (applicationName: string,
    configKey: string,) => {


  

  return `/apps/${applicationName}/configs/${configKey}`
}

export const reset = async (applicationName: string,
    configKey: string, options?: RequestInit): Promise<resetResponse> => {
  
  return customFetch<resetResponse>(getResetUrl(applicationName,configKey),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Reloads the system configuration and the configuration of all applications
 */
export type reloadResponse200 = {
  data: void
  status: 200
}

export type reloadResponse401 = {
  data: void
  status: 401
}
    
export type reloadResponseSuccess = (reloadResponse200) & {
  headers: Headers;
};
export type reloadResponseError = (reloadResponse401) & {
  headers: Headers;
};

export type reloadResponse = (reloadResponseSuccess | reloadResponseError)

export const getReloadUrl = () => {


  

  return `/config/reload`
}

export const reload = async ( options?: RequestInit): Promise<reloadResponse> => {
  
  return customFetch<reloadResponse>(getReloadUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Returns the value of the config with the given name.
 */
export type get1Response200 = {
  data: void
  status: 200
}

export type get1Response401 = {
  data: void
  status: 401
}

export type get1Response404 = {
  data: void
  status: 404
}
    
export type get1ResponseSuccess = (get1Response200) & {
  headers: Headers;
};
export type get1ResponseError = (get1Response401 | get1Response404) & {
  headers: Headers;
};

export type get1Response = (get1ResponseSuccess | get1ResponseError)

export const getGet1Url = (configKey: string,) => {


  

  return `/configs/${configKey}`
}

export const get1 = async (configKey: string, options?: RequestInit): Promise<get1Response> => {
  
  return customFetch<get1Response>(getGet1Url(configKey),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Sets a new value for the config with the given name.
 */
export type set1Response200 = {
  data: void
  status: 200
}

export type set1Response401 = {
  data: void
  status: 401
}
    
export type set1ResponseSuccess = (set1Response200) & {
  headers: Headers;
};
export type set1ResponseError = (set1Response401) & {
  headers: Headers;
};

export type set1Response = (set1ResponseSuccess | set1ResponseError)

export const getSet1Url = (configKey: string,
    params?: Set1Params,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/configs/${configKey}?${stringifiedParams}` : `/configs/${configKey}`
}

export const set1 = async (configKey: string,
    set1Body: string,
    params?: Set1Params, options?: RequestInit): Promise<set1Response> => {
  
  return customFetch<set1Response>(getSet1Url(configKey,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': '*/*', ...options?.headers },
    body: JSON.stringify(
      set1Body,)
  }
);}



/**
 * Resets the config with the given name to the default value.
 */
export type reset1Response200 = {
  data: void
  status: 200
}

export type reset1Response401 = {
  data: void
  status: 401
}

export type reset1Response404 = {
  data: void
  status: 404
}
    
export type reset1ResponseSuccess = (reset1Response200) & {
  headers: Headers;
};
export type reset1ResponseError = (reset1Response401 | reset1Response404) & {
  headers: Headers;
};

export type reset1Response = (reset1ResponseSuccess | reset1ResponseError)

export const getReset1Url = (configKey: string,) => {


  

  return `/configs/${configKey}`
}

export const reset1 = async (configKey: string, options?: RequestInit): Promise<reset1Response> => {
  
  return customFetch<reset1Response>(getReset1Url(configKey),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Returns the value of the variable with the given name.
 */
export type get2Response200 = {
  data: void
  status: 200
}

export type get2Response401 = {
  data: void
  status: 401
}

export type get2Response404 = {
  data: void
  status: 404
}
    
export type get2ResponseSuccess = (get2Response200) & {
  headers: Headers;
};
export type get2ResponseError = (get2Response401 | get2Response404) & {
  headers: Headers;
};

export type get2Response = (get2ResponseSuccess | get2ResponseError)

export const getGet2Url = (applicationName: string,
    variableName: string,) => {


  

  return `/apps/${applicationName}/variables/${variableName}`
}

export const get2 = async (applicationName: string,
    variableName: string, options?: RequestInit): Promise<get2Response> => {
  
  return customFetch<get2Response>(getGet2Url(applicationName,variableName),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Sets a new value for the variable with the given name.
 */
export type set2Response200 = {
  data: void
  status: 200
}

export type set2Response401 = {
  data: void
  status: 401
}

export type set2Response404 = {
  data: void
  status: 404
}
    
export type set2ResponseSuccess = (set2Response200) & {
  headers: Headers;
};
export type set2ResponseError = (set2Response401 | set2Response404) & {
  headers: Headers;
};

export type set2Response = (set2ResponseSuccess | set2ResponseError)

export const getSet2Url = (applicationName: string,
    variableName: string,
    params?: Set2Params,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/apps/${applicationName}/variables/${variableName}?${stringifiedParams}` : `/apps/${applicationName}/variables/${variableName}`
}

export const set2 = async (applicationName: string,
    variableName: string,
    set2Body: string,
    params?: Set2Params, options?: RequestInit): Promise<set2Response> => {
  
  return customFetch<set2Response>(getSet2Url(applicationName,variableName,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': '*/*', ...options?.headers },
    body: JSON.stringify(
      set2Body,)
  }
);}



/**
 * Resets the variable with the given name to the default value.
 */
export type reset2Response200 = {
  data: void
  status: 200
}

export type reset2Response401 = {
  data: void
  status: 401
}

export type reset2Response404 = {
  data: void
  status: 404
}
    
export type reset2ResponseSuccess = (reset2Response200) & {
  headers: Headers;
};
export type reset2ResponseError = (reset2Response401 | reset2Response404) & {
  headers: Headers;
};

export type reset2Response = (reset2ResponseSuccess | reset2ResponseError)

export const getReset2Url = (applicationName: string,
    variableName: string,) => {


  

  return `/apps/${applicationName}/variables/${variableName}`
}

export const reset2 = async (applicationName: string,
    variableName: string, options?: RequestInit): Promise<reset2Response> => {
  
  return customFetch<reset2Response>(getReset2Url(applicationName,variableName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Deploys a project .iar file or multiple projects in a .zip file to an application.
 */
export type deployResponse200 = {
  data: void
  status: 200
}

export type deployResponse201 = {
  data: void
  status: 201
}

export type deployResponse401 = {
  data: void
  status: 401
}

export type deployResponse500 = {
  data: void
  status: 500
}

export type deployResponse503 = {
  data: void
  status: 503
}
    
export type deployResponseSuccess = (deployResponse200 | deployResponse201) & {
  headers: Headers;
};
export type deployResponseError = (deployResponse401 | deployResponse500 | deployResponse503) & {
  headers: Headers;
};

export type deployResponse = (deployResponseSuccess | deployResponseError)

export const getDeployUrl = (applicationName: string,) => {


  

  return `/apps/${applicationName}`
}

export const deploy = async (applicationName: string,
    deployBody: DeployBody, options?: RequestInit): Promise<deployResponse> => {
    const formData = new FormData();
formData.append(`fileToDeploy`, deployBody.fileToDeploy)
if(deployBody.deploymentOptions !== undefined) {
 formData.append(`deploymentOptions`, deployBody.deploymentOptions)
 }
if(deployBody.deployTestUsers !== undefined) {
 formData.append(`deployTestUsers`, deployBody.deployTestUsers)
 }
if(deployBody.targetVersion !== undefined) {
 formData.append(`targetVersion`, deployBody.targetVersion)
 }
if(deployBody.targetState !== undefined) {
 formData.append(`targetState`, deployBody.targetState)
 }

  return customFetch<deployResponse>(getDeployUrl(applicationName),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}



/**
 * Returns the version and the name of the engine
 */
export type getInfoResponseDefault = {
  data: EngineInfo
  status: number
}
    
;
export type getInfoResponseError = (getInfoResponseDefault) & {
  headers: Headers;
};

export type getInfoResponse = (getInfoResponseError)

export const getGetInfoUrl = () => {


  

  return `/engine/info`
}

export const getInfo = async ( options?: RequestInit): Promise<getInfoResponse> => {
  
  return customFetch<getInfoResponse>(getGetInfoUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export type configurationsResponseDefault = {
  data: ConfigurationIdentifier[]
  status: number
}
    
;
export type configurationsResponseError = (configurationsResponseDefault) & {
  headers: Headers;
};

export type configurationsResponse = (configurationsResponseError)

export const getConfigurationsUrl = () => {


  

  return `/web-ide/configurations`
}

export const configurations = async ( options?: RequestInit): Promise<configurationsResponse> => {
  
  return customFetch<configurationsResponse>(getConfigurationsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export type readConfigResponseDefault = {
  data: ConfigurationBean
  status: number
}
    
;
export type readConfigResponseError = (readConfigResponseDefault) & {
  headers: Headers;
};

export type readConfigResponse = (readConfigResponseError)

export const getReadConfigUrl = (params?: ReadConfigParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/web-ide/configuration?${stringifiedParams}` : `/web-ide/configuration`
}

export const readConfig = async (params?: ReadConfigParams, options?: RequestInit): Promise<readConfigResponse> => {
  
  return customFetch<readConfigResponse>(getReadConfigUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export type writeConfigResponseDefault = {
  data: ConfigurationBean
  status: number
}
    
;
export type writeConfigResponseError = (writeConfigResponseDefault) & {
  headers: Headers;
};

export type writeConfigResponse = (writeConfigResponseError)

export const getWriteConfigUrl = () => {


  

  return `/web-ide/configuration`
}

export const writeConfig = async (configurationBean: ConfigurationBean, options?: RequestInit): Promise<writeConfigResponse> => {
  
  return customFetch<writeConfigResponse>(getWriteConfigUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      configurationBean,)
  }
);}



export type dataClassesResponseDefault = {
  data: DataClassBean[]
  status: number
}
    
;
export type dataClassesResponseError = (dataClassesResponseDefault) & {
  headers: Headers;
};

export type dataClassesResponse = (dataClassesResponseError)

export const getDataClassesUrl = (params?: DataClassesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/web-ide/dataclasses?${stringifiedParams}` : `/web-ide/dataclasses`
}

export const dataClasses = async (params?: DataClassesParams, options?: RequestInit): Promise<dataClassesResponse> => {
  
  return customFetch<dataClassesResponse>(getDataClassesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export type createDataClassResponseDefault = {
  data: DataClassBean
  status: number
}
    
;
export type createDataClassResponseError = (createDataClassResponseDefault) & {
  headers: Headers;
};

export type createDataClassResponse = (createDataClassResponseError)

export const getCreateDataClassUrl = () => {


  

  return `/web-ide/dataclass`
}

export const createDataClass = async (dataClassInit: DataClassInit, options?: RequestInit): Promise<createDataClassResponse> => {
  
  return customFetch<createDataClassResponse>(getCreateDataClassUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      dataClassInit,)
  }
);}



export type deleteDataClassResponseDefault = {
  data: DataClassIdentifier
  status: number
}
    
;
export type deleteDataClassResponseError = (deleteDataClassResponseDefault) & {
  headers: Headers;
};

export type deleteDataClassResponse = (deleteDataClassResponseError)

export const getDeleteDataClassUrl = () => {


  

  return `/web-ide/dataclass`
}

export const deleteDataClass = async (dataClassIdentifier: DataClassIdentifier, options?: RequestInit): Promise<deleteDataClassResponse> => {
  
  return customFetch<deleteDataClassResponse>(getDeleteDataClassUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      dataClassIdentifier,)
  }
);}



export type formsResponseDefault = {
  data: HdBean[]
  status: number
}
    
;
export type formsResponseError = (formsResponseDefault) & {
  headers: Headers;
};

export type formsResponse = (formsResponseError)

export const getFormsUrl = () => {


  

  return `/web-ide/forms`
}

export const forms = async ( options?: RequestInit): Promise<formsResponse> => {
  
  return customFetch<formsResponse>(getFormsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export type componentFormResponseDefault = {
  data: HdBean
  status: number
}
    
;
export type componentFormResponseError = (componentFormResponseDefault) & {
  headers: Headers;
};

export type componentFormResponse = (componentFormResponseError)

export const getComponentFormUrl = (params?: ComponentFormParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/web-ide/form?${stringifiedParams}` : `/web-ide/form`
}

export const componentForm = async (params?: ComponentFormParams, options?: RequestInit): Promise<componentFormResponse> => {
  
  return customFetch<componentFormResponse>(getComponentFormUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export type deleteFormResponseDefault = {
  data: unknown
  status: number
}
    
;
export type deleteFormResponseError = (deleteFormResponseDefault) & {
  headers: Headers;
};

export type deleteFormResponse = (deleteFormResponseError)

export const getDeleteFormUrl = () => {


  

  return `/web-ide/form`
}

export const deleteForm = async (formIdentifier: FormIdentifier, options?: RequestInit): Promise<deleteFormResponse> => {
  
  return customFetch<deleteFormResponse>(getDeleteFormUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      formIdentifier,)
  }
);}



export type createHdResponseDefault = {
  data: HdBean
  status: number
}
    
;
export type createHdResponseError = (createHdResponseDefault) & {
  headers: Headers;
};

export type createHdResponse = (createHdResponseError)

export const getCreateHdUrl = () => {


  

  return `/web-ide/hd`
}

export const createHd = async (hdInit: HdInit, options?: RequestInit): Promise<createHdResponse> => {
  
  return customFetch<createHdResponse>(getCreateHdUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      hdInit,)
  }
);}



export type importProcessResponseDefault = {
  data: unknown
  status: number
}
    
;
export type importProcessResponseError = (importProcessResponseDefault) & {
  headers: Headers;
};

export type importProcessResponse = (importProcessResponseError)

export const getImportProcessUrl = () => {


  

  return `/web-ide/process/import/xml`
}

export const importProcess = async (importProcessBody: ImportProcessBody, options?: RequestInit): Promise<importProcessResponse> => {
    const formData = new FormData();
if(importProcessBody.app !== undefined) {
 formData.append(`app`, importProcessBody.app)
 }
if(importProcessBody.pmv !== undefined) {
 formData.append(`pmv`, importProcessBody.pmv)
 }
if(importProcessBody.projectDir !== undefined) {
 formData.append(`projectDir`, importProcessBody.projectDir)
 }
if(importProcessBody.file !== undefined) {
 formData.append(`file`, importProcessBody.file)
 }

  return customFetch<importProcessResponse>(getImportProcessUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}



export type getProcessesResponseDefault = {
  data: ProcessBean[]
  status: number
}
    
;
export type getProcessesResponseError = (getProcessesResponseDefault) & {
  headers: Headers;
};

export type getProcessesResponse = (getProcessesResponseError)

export const getGetProcessesUrl = () => {


  

  return `/web-ide/processes`
}

export const getProcesses = async ( options?: RequestInit): Promise<getProcessesResponse> => {
  
  return customFetch<getProcessesResponse>(getGetProcessesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export type createProcessResponseDefault = {
  data: ProcessBean
  status: number
}
    
;
export type createProcessResponseError = (createProcessResponseDefault) & {
  headers: Headers;
};

export type createProcessResponse = (createProcessResponseError)

export const getCreateProcessUrl = () => {


  

  return `/web-ide/process`
}

export const createProcess = async (processInit: ProcessInit, options?: RequestInit): Promise<createProcessResponse> => {
  
  return customFetch<createProcessResponse>(getCreateProcessUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      processInit,)
  }
);}



export type deleteProcessResponseDefault = {
  data: unknown
  status: number
}
    
;
export type deleteProcessResponseError = (deleteProcessResponseDefault) & {
  headers: Headers;
};

export type deleteProcessResponse = (deleteProcessResponseError)

export const getDeleteProcessUrl = () => {


  

  return `/web-ide/process`
}

export const deleteProcess = async (processIdentifier: ProcessIdentifier, options?: RequestInit): Promise<deleteProcessResponse> => {
  
  return customFetch<deleteProcessResponse>(getDeleteProcessUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      processIdentifier,)
  }
);}



export type buildProjectsResponseDefault = {
  data: unknown
  status: number
}
    
;
export type buildProjectsResponseError = (buildProjectsResponseDefault) & {
  headers: Headers;
};

export type buildProjectsResponse = (buildProjectsResponseError)

export const getBuildProjectsUrl = () => {


  

  return `/web-ide/projects/build`
}

export const buildProjects = async (buildProjectsBody: string[], options?: RequestInit): Promise<buildProjectsResponse> => {
  
  return customFetch<buildProjectsResponse>(getBuildProjectsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': '*/*', ...options?.headers },
    body: JSON.stringify(
      buildProjectsBody,)
  }
);}



export type deployProjectsResponseDefault = {
  data: unknown
  status: number
}
    
;
export type deployProjectsResponseError = (deployProjectsResponseDefault) & {
  headers: Headers;
};

export type deployProjectsResponse = (deployProjectsResponseError)

export const getDeployProjectsUrl = () => {


  

  return `/web-ide/projects/deploy`
}

export const deployProjects = async (deployProjectsBody: string[], options?: RequestInit): Promise<deployProjectsResponse> => {
  
  return customFetch<deployProjectsResponse>(getDeployProjectsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': '*/*', ...options?.headers },
    body: JSON.stringify(
      deployProjectsBody,)
  }
);}



export type projectsResponseDefault = {
  data: ProjectBean[]
  status: number
}
    
;
export type projectsResponseError = (projectsResponseDefault) & {
  headers: Headers;
};

export type projectsResponse = (projectsResponseError)

export const getProjectsUrl = (params?: ProjectsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/web-ide/projects?${stringifiedParams}` : `/web-ide/projects`
}

export const projects = async (params?: ProjectsParams, options?: RequestInit): Promise<projectsResponse> => {
  
  return customFetch<projectsResponse>(getProjectsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export type refreshProjectStatusesResponseDefault = {
  data: ProjectBean[]
  status: number
}
    
;
export type refreshProjectStatusesResponseError = (refreshProjectStatusesResponseDefault) & {
  headers: Headers;
};

export type refreshProjectStatusesResponse = (refreshProjectStatusesResponseError)

export const getRefreshProjectStatusesUrl = () => {


  

  return `/web-ide/projects/refreshProjectStatuses`
}

export const refreshProjectStatuses = async ( options?: RequestInit): Promise<refreshProjectStatusesResponse> => {
  
  return customFetch<refreshProjectStatusesResponse>(getRefreshProjectStatusesUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



export type convertProjectResponseDefault = {
  data: unknown
  status: number
}
    
;
export type convertProjectResponseError = (convertProjectResponseDefault) & {
  headers: Headers;
};

export type convertProjectResponse = (convertProjectResponseError)

export const getConvertProjectUrl = (params?: ConvertProjectParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/web-ide/project/convert?${stringifiedParams}` : `/web-ide/project/convert`
}

export const convertProject = async (params?: ConvertProjectParams, options?: RequestInit): Promise<convertProjectResponse> => {
  
  return customFetch<convertProjectResponse>(getConvertProjectUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



export type createPmvAndProjectFilesResponseDefault = {
  data: ProjectBean
  status: number
}
    
;
export type createPmvAndProjectFilesResponseError = (createPmvAndProjectFilesResponseDefault) & {
  headers: Headers;
};

export type createPmvAndProjectFilesResponse = (createPmvAndProjectFilesResponseError)

export const getCreatePmvAndProjectFilesUrl = () => {


  

  return `/web-ide/project/new`
}

export const createPmvAndProjectFiles = async (newProjectParams: NewProjectParams, options?: RequestInit): Promise<createPmvAndProjectFilesResponse> => {
  
  return customFetch<createPmvAndProjectFilesResponse>(getCreatePmvAndProjectFilesUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      newProjectParams,)
  }
);}



export type findOrCreatePmvResponseDefault = {
  data: unknown
  status: number
}
    
;
export type findOrCreatePmvResponseError = (findOrCreatePmvResponseDefault) & {
  headers: Headers;
};

export type findOrCreatePmvResponse = (findOrCreatePmvResponseError)

export const getFindOrCreatePmvUrl = () => {


  

  return `/web-ide/project`
}

export const findOrCreatePmv = async (projectParams: ProjectParams, options?: RequestInit): Promise<findOrCreatePmvResponse> => {
  
  return customFetch<findOrCreatePmvResponse>(getFindOrCreatePmvUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectParams,)
  }
);}



export type deleteProjectResponseDefault = {
  data: unknown
  status: number
}
    
;
export type deleteProjectResponseError = (deleteProjectResponseDefault) & {
  headers: Headers;
};

export type deleteProjectResponse = (deleteProjectResponseError)

export const getDeleteProjectUrl = (params?: DeleteProjectParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/web-ide/project?${stringifiedParams}` : `/web-ide/project`
}

export const deleteProject = async (params?: DeleteProjectParams, options?: RequestInit): Promise<deleteProjectResponse> => {
  
  return customFetch<deleteProjectResponse>(getDeleteProjectUrl(params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



export type stopBpmEngineResponseDefault = {
  data: unknown
  status: number
}
    
;
export type stopBpmEngineResponseError = (stopBpmEngineResponseDefault) & {
  headers: Headers;
};

export type stopBpmEngineResponse = (stopBpmEngineResponseError)

export const getStopBpmEngineUrl = (params?: StopBpmEngineParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/web-ide/project/stop-bpm-engine?${stringifiedParams}` : `/web-ide/project/stop-bpm-engine`
}

export const stopBpmEngine = async (params?: StopBpmEngineParams, options?: RequestInit): Promise<stopBpmEngineResponse> => {
  
  return customFetch<stopBpmEngineResponse>(getStopBpmEngineUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



export type dependenciesResponseDefault = {
  data: ProjectIdentifier[]
  status: number
}
    
;
export type dependenciesResponseError = (dependenciesResponseDefault) & {
  headers: Headers;
};

export type dependenciesResponse = (dependenciesResponseError)

export const getDependenciesUrl = (app: string,
    pmv: string,) => {


  

  return `/web-ide/project/${app}/${pmv}/dependencies`
}

export const dependencies = async (app: string,
    pmv: string, options?: RequestInit): Promise<dependenciesResponse> => {
  
  return customFetch<dependenciesResponse>(getDependenciesUrl(app,pmv),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export type addDependencyResponseDefault = {
  data: unknown
  status: number
}
    
;
export type addDependencyResponseError = (addDependencyResponseDefault) & {
  headers: Headers;
};

export type addDependencyResponse = (addDependencyResponseError)

export const getAddDependencyUrl = (app: string,
    pmv: string,) => {


  

  return `/web-ide/project/${app}/${pmv}/dependency`
}

export const addDependency = async (app: string,
    pmv: string,
    projectIdentifier: ProjectIdentifier, options?: RequestInit): Promise<addDependencyResponse> => {
  
  return customFetch<addDependencyResponse>(getAddDependencyUrl(app,pmv),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectIdentifier,)
  }
);}



export type removeDependencyResponseDefault = {
  data: unknown
  status: number
}
    
;
export type removeDependencyResponseError = (removeDependencyResponseDefault) & {
  headers: Headers;
};

export type removeDependencyResponse = (removeDependencyResponseError)

export const getRemoveDependencyUrl = (app: string,
    pmv: string,
    dependencyApp: string,
    dependencyPmv: string,) => {


  

  return `/web-ide/project/${app}/${pmv}/dependency/${dependencyApp}/${dependencyPmv}`
}

export const removeDependency = async (app: string,
    pmv: string,
    dependencyApp: string,
    dependencyPmv: string, options?: RequestInit): Promise<removeDependencyResponse> => {
  
  return customFetch<removeDependencyResponse>(getRemoveDependencyUrl(app,pmv,dependencyApp,dependencyPmv),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Returns the current user.
 */
export type me1ResponseDefault = {
  data: UserBean
  status: number
}
    
;
export type me1ResponseError = (me1ResponseDefault) & {
  headers: Headers;
};

export type me1Response = (me1ResponseError)

export const getMe1Url = () => {


  

  return `/web-ide/me`
}

export const me1 = async ( options?: RequestInit): Promise<me1Response> => {
  
  return customFetch<me1Response>(getMe1Url(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Logs out the current user.
 */
export type logoutMeResponseDefault = {
  data: unknown
  status: number
}
    
;
export type logoutMeResponseError = (logoutMeResponseDefault) & {
  headers: Headers;
};

export type logoutMeResponse = (logoutMeResponseError)

export const getLogoutMeUrl = () => {


  

  return `/web-ide/me`
}

export const logoutMe = async ( options?: RequestInit): Promise<logoutMeResponse> => {
  
  return customFetch<logoutMeResponse>(getLogoutMeUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



export type workspacesResponseDefault = {
  data: WorkspaceBean[]
  status: number
}
    
;
export type workspacesResponseError = (workspacesResponseDefault) & {
  headers: Headers;
};

export type workspacesResponse = (workspacesResponseError)

export const getWorkspacesUrl = () => {


  

  return `/web-ide/workspaces`
}

export const workspaces = async ( options?: RequestInit): Promise<workspacesResponse> => {
  
  return customFetch<workspacesResponse>(getWorkspacesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export type createWorkspaceResponseDefault = {
  data: WorkspaceBean
  status: number
}
    
;
export type createWorkspaceResponseError = (createWorkspaceResponseDefault) & {
  headers: Headers;
};

export type createWorkspaceResponse = (createWorkspaceResponseError)

export const getCreateWorkspaceUrl = () => {


  

  return `/web-ide/workspace`
}

export const createWorkspace = async (workspaceInit: WorkspaceInit, options?: RequestInit): Promise<createWorkspaceResponse> => {
  
  return customFetch<createWorkspaceResponse>(getCreateWorkspaceUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      workspaceInit,)
  }
);}



export type exportWorkspaceResponseDefault = {
  data: unknown
  status: number
}
    
;
export type exportWorkspaceResponseError = (exportWorkspaceResponseDefault) & {
  headers: Headers;
};

export type exportWorkspaceResponse = (exportWorkspaceResponseError)

export const getExportWorkspaceUrl = (id: string,) => {


  

  return `/web-ide/workspace/${id}`
}

export const exportWorkspace = async (id: string, options?: RequestInit): Promise<exportWorkspaceResponse> => {
  
  return customFetch<exportWorkspaceResponse>(getExportWorkspaceUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export type importProjectsResponseDefault = {
  data: unknown
  status: number
}
    
;
export type importProjectsResponseError = (importProjectsResponseDefault) & {
  headers: Headers;
};

export type importProjectsResponse = (importProjectsResponseError)

export const getImportProjectsUrl = (id: string,) => {


  

  return `/web-ide/workspace/${id}`
}

export const importProjects = async (id: string,
    importProjectsBody: ImportProjectsBody, options?: RequestInit): Promise<importProjectsResponse> => {
    const formData = new FormData();
if(importProjectsBody.file !== undefined) {
 formData.append(`file`, importProjectsBody.file)
 }
if(importProjectsBody.dependentProject !== undefined) {
 formData.append(`dependentProject`, importProjectsBody.dependentProject)
 }

  return customFetch<importProjectsResponse>(getImportProjectsUrl(id),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}



export type deleteWorkspaceResponseDefault = {
  data: unknown
  status: number
}
    
;
export type deleteWorkspaceResponseError = (deleteWorkspaceResponseDefault) & {
  headers: Headers;
};

export type deleteWorkspaceResponse = (deleteWorkspaceResponseError)

export const getDeleteWorkspaceUrl = (id: string,) => {


  

  return `/web-ide/workspace/${id}`
}

export const deleteWorkspace = async (id: string, options?: RequestInit): Promise<deleteWorkspaceResponse> => {
  
  return customFetch<deleteWorkspaceResponse>(getDeleteWorkspaceUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



export type installMarketProductResponseDefault = {
  data: MarketInstallResult
  status: number
}
    
;
export type installMarketProductResponseError = (installMarketProductResponseDefault) & {
  headers: Headers;
};

export type installMarketProductResponse = (installMarketProductResponseError)

export const getInstallMarketProductUrl = (id: string,) => {


  

  return `/web-ide/workspace/install/${id}`
}

export const installMarketProduct = async (id: string,
    productInstallParams: ProductInstallParams, options?: RequestInit): Promise<installMarketProductResponse> => {
  
  return customFetch<installMarketProductResponse>(getInstallMarketProductUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      productInstallParams,)
  }
);}
